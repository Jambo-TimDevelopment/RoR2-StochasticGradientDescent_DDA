# Правила проекта: DDA (SGD) для Risk of Rain 2

Этот мод — исследовательская реализация **системы динамической адаптации уровня сложности** (Dynamic Difficulty Adjustment, DDA) для магистерской диссертации.

- **Референс в репозитории**: существующий генетический алгоритм (папка `GeneticEngine/`).
- **Целевой алгоритм диссертации**: DDA на основе **стохастического градиентного спуска** (SGD) поверх архитектуры *Sensors → Decision module → Actuators*.

---

## Архитектура DDA

```
Sensors (метрики игрока) → Decision module (SGD) → Actuators (параметры сложности)
```

- **Sensors (сенсоры)**: собирают телеметрию и оценивают компоненты навыка игрока \(S_{p_i}\) и виртуальной силы \(V_p\) в скользящем временном окне.
- **Decision module (модуль решений, SGD)**: минимизирует целевую функцию баланса (см. ниже), вычисляет/аппроксимирует градиент и обновляет параметры сложности (вектор \(\theta\)).
- **Actuators (актуаторы)**: применяют \(\theta\) к игровому миру. В текущей реализации это в основном **числовые модификаторы статов монстров** (`GeneStat`), т.е. управление \(V_c\).

---

## Термины и модель сложности (Schreiber)

Используем модель **воспринимаемой сложности**:

\[
C = (V_c + S_c) - (V_p + S_p)
\]

Где:

- **\(S_p\) (skill of player / навык игрока)**: измеримые проявления умения игрока управлять персонажем и принимать решения (механика, тактика, управление ресурсами, адаптивность). В моде это источник данных для **сенсоров**.
- **\(V_p\) (virtual power / виртуальная сила игрока)**: «числовая мощь» игрока, не связанная напрямую с умением (набор предметов, уровни, стаки, синергии, проки, выбор персонажа/снаряжения). Это важно учитывать, чтобы DDA не «наказывал» сильный билд, принимая его за высокий \(S_p\).
- **\(V_c\) (virtual challenge / виртуальная сложность)**: «числовая» сложность, задаваемая множителями и параметрами врагов. **Текущая реализация мода в основном управляет именно \(V_c\)** через множители `GeneStat` (HP/урон/скорости).
- **\(S_c\) (skill required by challenge / требуемый навык)**: тактическая/поведенческая сложность, т.е. какие навыки требует игра (паттерны атак, агрессия/координация, типы врагов, плотность/структура волн, контр‑игра против кайт/прыжков и т.п.). В текущей версии это рассматривается как направление расширения архитектуры (см. заметки по интеграции).

Интерпретация знака \(C\):

- **\(C > 0\)**: игра воспринимается сложнее желаемого (челлендж «перекрывает» силу и навык игрока) → адаптация должна снижать \(V_c\) и/или \(S_c\).
- **\(C < 0\)**: игра воспринимается слишком простой → адаптация может повышать \(V_c\) и/или \(S_c\) в безопасных пределах.

---

## Стек и зависимости

- **BepInEx** — загрузчик модов.
- **R2API** — ArtifactCode, ContentManagement, Items, Language, RecalculateStats, CommandHelper.
- **RoR2 API** — Run, CharacterBody, HealthComponent, TeamIndex, RunArtifactManager, Stage.
- **On.** — хуки/патчинг (например, `On.RoR2.HealthComponent.TakeDamage`).

---

## Ключевые файлы и их роли

| Файл | Назначение |
|------|------------|
| `GeneticsArtifactPlugin.cs` | Точка входа, `Awake`, инициализация подсистем |
| `CheatManager/DdaAlgorithmState.cs` | Рантайм‑состояние: `IsGeneticAlgorithmEnabled`, `ActiveAlgorithm` (Genetic/Sgd), `IsDebugOverlayEnabled` |
| `CheatManager/DdaCheatManager.cs` | Консольные команды: `dda_genetics`, `dda_algorithm`, `dda_debug_overlay`, `dda_param` |
| `GeneticEngine/GeneEngineDriver.cs` | Драйвер генетического алгоритма; хуки Run_Start, CharacterBody_Start, HealthComponent_TakeDamage |
| `GeneticEngine/MonsterGeneBehaviour.cs` | Данные по монстру: `currentGenes`, `damageDealt`, `timeAlive`, `timeEngaged`, `score` |
| `GeneticEngine/MasterGeneBehaviour.cs` | «Мастер‑копия» генов для типа монстра; `MutateFromChildren` — обучение по score |
| `GeneticEngine/GeneTokenCalc.cs` | `RecalculateStatsAPI`: перевод генов в модификаторы статов |
| `GeneticEngine/GeneTokens.cs` | ItemDef для GeneStat (MaxHealth, MoveSpeed, AttackSpeed, AttackDamage) |
| `ArtifactResources/ConfigManager.cs` | BepInEx‑конфиг: `timeLimit`, `deathLimit`, `geneFloor`, `geneCap` и др. |

---

## Код‑паттерны (инварианты интеграции)

1. **Проверка сервера**: DDA‑логика исполняется только при `NetworkServer.active`.
2. **Проверка артефакта**: `RunArtifactManager.instance.IsArtifactEnabled(ArtifactOfGenetics.artifactDef)`.
3. **Выбор алгоритма**: ветвления под SGD защищаются `DdaAlgorithmState.ActiveAlgorithm == DdaAlgorithmType.Sgd`.
4. **Монстры**: `teamIndex == TeamIndex.Monster` и `inventory != null`.
5. **Логи**: `GeneticsArtifactPlugin.geneticLogSource.LogInfo/LogWarning/LogError`.
6. **Игроки**: `TeamIndex.Player`; для сенсоров — `CharacterBody` с `isPlayerControlled` или `CharacterMaster`.

---

## Реализация модулей DDA

### Модуль сенсоров

Цель сенсоров в рамках **MVP‑адаптации через 4 актуатора `GeneStat`** (HP/MoveSpeed/AttackSpeed/AttackDamage) — дать модулю решений минимальный набор устойчивых сигналов, чтобы:

- отличать «слишком легко» от «слишком сложно»;
- корректно учитывать **виртуальную силу билда** \(V_p(t)\);
- разруливать вклад актуаторов (HP vs DMG/AS vs MS) без реакции на RNG‑шум.

#### Обязательный список сенсоров (под 4 актуатора)

1) **Входящий урон и риск смерти** (контролирует DMG/AS, частично MS)
   - `IncomingDamageRate` — входящий урон в секунду (в бою)
   - `LowHealthUptime` — доля времени с HP% ниже порога (например, <30%)
   - `DeathsPerWindow` — число смертей/нокдаунов за окно наблюдения

2) **Эффективность уничтожения врагов** (контролирует HP)
   - `OutgoingDamageRate` — исходящий урон по монстрам в секунду
   - `AvgTTK` — среднее время убийства (или прокси через длительность столкновений/KPM)

3) **Контактность и уклонение** (разделяет MS vs AS)
   - `HitRateOnPlayer` — частота попаданий по игроку в бою
   - `CombatUptime` — доля времени «в бою» (не outOfCombat)

4) **Виртуальная сила билда \(V_p(t)\)** (для члена \(\alpha (V_c - V_p)^2\))
   - `V_p.offense`, `V_p.defense`, `V_p.mobility`, `V_p.total` (см. формулу ниже)

#### Формула \(V_p(t)\) (реализовано в `SgdEngine/`)
Используется абсолютная прокси‑оценка + лог‑сжатие диапазона + EMA‑сглаживание:

- `OffenseRaw = damage * attackSpeed * (1 + critChance)`
- `DefenseRaw = EHP + RegenWeight * regen`, где `EHP ≈ (maxHealth + maxShield) * clamp((100 + armor)/100, 0.05, 10)`
- `MobilityRaw = moveSpeed`

Далее (компрессия):
- `Offense = log(1 + OffenseRaw)`
- `Defense = log(1 + DefenseRaw)`
- `Mobility = log(1 + MobilityRaw)`
- `Total = 0.50*Offense + 0.35*Defense + 0.15*Mobility`

Сглаживание (EMA):
- `xEma = lerp(xEma, x, 1 - exp(-dt/τ))`, где \(\tau\) по умолчанию ~7.5 сек.

### Модуль актуаторов

Актуаторы применяют параметры сложности \(\theta\) к миру игры. В терминах модели это рычаги для управления \(V_c\) и (в расширении) \(S_c\).

- **Текущий “рычаг” (реализовано генетическим движком)** — числовые модификаторы статов монстров через `GeneStat`:
  - `MaxHealth` (HP), `MoveSpeed`, `AttackSpeed`, `AttackDamage`.
  - Точка применения: `RecalculateStatsAPI` (`GeneTokenCalc`) и/или прямые модификации `CharacterBody`.
- **Потенциальные рычаги \(S_c\)** (архитектурно поддерживается как направление расширения):
  - агрессивность/временные окна атак (реакция на механическое мастерство),
  - координация/состав волн (требования к тактике и контролю территории),
  - распределение ресурсов (боеприпасы/лечение) как часть «ресурсного вызова».

#### Маппинг компонентов сложности (диссертация → актуаторы)
Целевая функция диссертации оперирует парами \(S_{p_i}\) ↔ \(S_{c_i}\) и дополнительно согласует \(V_p\) ↔ \(V_c\). На практике это означает следующий «перевод» в рычаги игры:

- **Механическое мастерство \(S_{p,mech}\)** ↔ **механический вызов \(S_{c,mech}\)**:
  - примеры \(S_{c,mech}\): точность/скорость снарядов противников, окна реакции, частота атак;
  - в текущем MVP‑контуре мода это чаще всего приближённо выражается через \(V_c\) (урон/скорость атаки/скорость движения монстров).
- **Тактическое мышление \(S_{p,tactic}\)** ↔ **тактический вызов \(S_{c,tactic}\)**:
  - примеры \(S_{c,tactic}\): агрессивность, координация, состав волн, фланги/окружения;
  - в текущем коде явные рычаги \(S_c\) ещё не реализованы и рассматриваются как расширение.
- **Ресурсный менеджмент \(S_{p,res}\)** ↔ **ресурсный вызов \(S_{c,res}\)**:
  - примеры \(S_{c,res}\): доступность лечения/боеприпасов/усилений и их распределение;
  - в текущем коде это также направление расширения.
- **Виртуальная сила \(V_p\)** ↔ **виртуальная сложность \(V_c\)**:
  - \(V_p\): «мощность билда» (предметы/стаки/проки),
  - \(V_c\): числовые множители мира, **которые мод уже умеет применять** через `GeneStat`.

Ограничение текущей реализации: на данный момент основной механизм воздействия — это `GeneStat`‑множители (т.е. \(V_c\)). Поэтому термины \(S_c\) и компоненты \(S_{c_i}\) фиксируются в документации как часть целевой модели диссертации и будущего расширения актуаторов, а не как уже существующая функциональность.

### Модуль решений (SGD)

Модуль решений выполняет **онлайн‑оптимизацию**: на каждом шаге адаптации обновляет \(\theta\) так, чтобы текущий вызов соответствовал текущим возможностям игрока, сохраняя психологическую безопасность (плавность и предсказуемость изменений).

- **Вход**: вектор метрик/оценок из сенсоров (оценки \(S_{p_i}(t)\), оценка \(V_p(t)\), вспомогательные статистики стабильности/шума).
- **Выход**: вектор параметров сложности \(\theta(t)\) для актуаторов (в текущей реализации — множители для `GeneStat`; в расширении — параметры \(S_{c_i}\)).
- **Частота обновления**: итеративно с фиксированным интервалом или по событию (аналогично `timeLimit`/`deathLimit` из генетического драйвера).

#### Итерация адаптации (по главе 3.3)
Алгоритм выполняет параллельную адаптацию по компонентам сложности и повторяет цикл с фиксированным интервалом:

1) **Оценка текущего состояния навыков**
   - измерение метрик для каждого \(S_{p_i}\) в окне \(W\),
   - нормализация и сглаживание,
   - оценка текущих отклонений \((S_{c_i}(t) - S_{p_i}(t))\) и \((V_c(t) - V_p(t))\).
2) **Вычисление градиентов**
   - вычисление/аппроксимация частных производных целевой функции по параметрам \(\theta\),
   - определение направления и величины корректировок,
   - при необходимости учёт взаимовлияния компонентов (в общем случае — через связь \(S_c(\theta)\), \(V_c(\theta)\)).
3) **Корректировка параметров сложности**
   - шаг в направлении антиградиента,
   - применение ограничений и сглаживания обновлений,
   - согласование обновлений между компонентами (например, не усиливать одновременно урон и скорость атаки сверх допустимого «скачка»).
4) **Мониторинг и обратная связь**
   - оценка реакции игрока на изменения,
   - при необходимости корректировка весов \(w_i\) (что именно считаем более важным),
   - контроль сходимости к «приемлемому балансу».

#### Модификации SGD для игровой задачи (по главе 3.2.1)
Для психологически безопасной и устойчивой адаптации используются следующие «надстройки» над базовым SGD:

- **Ограничение шага/градиента (clipping)**: предотвращает резкие скачки сложности при выбросах метрик.
- **Адаптивная скорость обучения \(\eta_t\)**: уменьшать \(\eta_t\) при высокой нестабильности/шуме метрик и увеличивать при стабильной картине.
- **Инерционный член (momentum)**: сглаживает траекторию оптимизации и делает изменения более предсказуемыми.
- **Ранняя остановка/заморозка**: если ошибка уже «достаточно мала» и колеблется вокруг нуля, временно прекращать обновления.
- **Cap/Floor и проекция**: жёсткие границы на \(\theta\) (и/или скорость изменения \(\Delta\theta\)) как защита от психологически небезопасных изменений.

---

## Математика алгоритма (из диссертации)

```
Целевая функция (ошибка баланса):
F(t) = Σ_i [ w_i · (S_c_i(t) - S_p_i(t))² ] + α · (V_c(t) - V_p(t))²

Обозначения:
- S_p_i(t): i‑тая компонента реального навыка игрока (точность, позиционирование, ресурсный менеджмент, ...)
- S_c_i(t): соответствующая компонента тактической сложности (требуемый навык)
- V_p(t): виртуальная сила (мощность билда)
- V_c(t): виртуальная сложность (числовые множители)
- w_i: вес важности навыка
- α: вес согласования виртуальной силы и виртуальной сложности

Параметризация:
- θ(t): вектор параметров сложности, которые реально изменяет модуль решений
  - текущий MVP: θ = [MaxHealth_mult, MoveSpeed_mult, AttackSpeed_mult, AttackDamage_mult]
  - при расширении: θ может включать параметры S_c (агрессия, координация, состав волн, ...)

Правило обновления (SGD):
θ_{t+1} = Project( θ_t - η_t · ∇_θ F(t) )

где:
- η_t: скорость обучения (контролирует плавность адаптации)
- Project(·): проекция на допустимые пределы (cap/floor), чтобы изменения были безопасными

Примечание про градиент:
- В общем случае \(S_c\) и \(V_c\) зависят от параметров \(\theta\) через маппинг актуаторов, поэтому \(\nabla_\theta F\) включает производные \(\partial S_{c_i}/\partial \theta\) и \(\partial V_c/\partial \theta\).
- В MVP‑варианте, когда отдельные компоненты сложности параметризуются напрямую (например, \(S_{c_i}(t) \equiv \theta_i(t)\) или \(V_c(t) \equiv \theta_v(t)\)), квадратичная форма даёт простой градиент вида:
  - \(\frac{\partial F}{\partial \theta_i} = 2 w_i (\theta_i - S_{p_i})\),
  - \(\frac{\partial F}{\partial \theta_v} = 2 \alpha (\theta_v - V_p)\).
- Это удобно для реализации «параллельного градиентного спуска» по компонентам.
```

---

## Структура папок

- **Все классы алгоритма автора (SGD/DDA)** должны находиться в **отдельной папке** проекта (например, `SgdEngine/` или `DdaEngine/`).
- Сенсоры, актуаторы и модуль решений SGD — только в этой папке.
- `CheatManager/` — общая инфраструктура (консольные команды, оверлей, состояние).
- `GeneticEngine/` — исходники генетического алгоритма (референс, не трогать).

## Защита генетического движка

- **Не модифицировать** файлы в `GeneticEngine/`: `GeneEngineDriver.cs`, `MasterGeneBehaviour.cs`, `MonsterGeneBehaviour.cs`, `GeneTokenCalc.cs`, `GeneTokens.cs`.
- Исключение: только **критически необходимые** изменения (блокирующий баг или минимальная точка интеграции по явному запросу).
- Интеграция SGD — через `DdaAlgorithmState.ActiveAlgorithm`, отдельный драйвер и хуки в `GeneticsArtifactPlugin`, **без** вмешательства в `GeneEngineDriver` и связанные классы.

---

## Стиль и принципы

- **SOLID, KISS**: один класс — одна ответственность; простые интерфейсы.
- **Именование**: префикс `Sgd` для новых DDA‑классов; `Gene` — для генетического алгоритма.
- **Namespace**: `GeneticsArtifact` для основного кода; `GeneticsArtifact.CheatManager` для CheatManager.
- **Чистка**: удалять неиспользуемый код.
- **Коммиты**: после каждого логического блока (сенсоры, актуаторы, модуль решений).

---

## Отладка

- Консоль: `dda_genetics 1`, `dda_algorithm sgd`, `dda_debug_overlay 1`.
- Логи: `GeneticsArtifactPlugin.geneticLogSource` в `BepInEx/LogOutput.log`.
- Оверлей: `DebugOverlayBehaviour` — расширять для вывода метрик сенсоров и параметров \(\theta\).
- `#if DEBUG` — дополнительное логирование в debug‑сборках.

---

## Интеграция с текущим кодом

- Когда `ActiveAlgorithm == Sgd` — использовать **отдельный SGD‑драйвер** в собственной папке, не модифицируя `GeneEngineDriver`.
- Точка входа: `GeneticsArtifactPlugin.Awake` — инициализировать SGD‑драйвер только для режима `Sgd`; хуки Run_Start, CharacterBody_Start и т.п. — в отдельном классе драйвера.
- Артефакт `ArtifactOfGenetics` остаётся общим: включение/выключение — через `dda_genetics` и `RunArtifactManager`.
- Важно: команда `dda_algorithm sgd` сейчас переключает состояние (`DdaAlgorithmState.ActiveAlgorithm = Sgd`), но в текущем коде SGD‑логика помечена как «not yet implemented» — документация описывает целевую архитектуру и математику диссертации.
